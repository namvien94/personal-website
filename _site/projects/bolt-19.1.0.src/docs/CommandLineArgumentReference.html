<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>commandlineargumentreference – Nam Vien</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Nam Vien</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../About.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../coursework.html"> 
<span class="menu-text">Coursework</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#bolt---a-post-link-optimizer-developed-to-speed-up-large-applications" id="toc-bolt---a-post-link-optimizer-developed-to-speed-up-large-applications" class="nav-link active" data-scroll-target="#bolt---a-post-link-optimizer-developed-to-speed-up-large-applications">BOLT - a post-link optimizer developed to speed up large applications</a>
  <ul class="collapse">
  <li><a href="#synopsis" id="toc-synopsis" class="nav-link" data-scroll-target="#synopsis">SYNOPSIS</a></li>
  <li><a href="#options" id="toc-options" class="nav-link" data-scroll-target="#options">OPTIONS</a>
  <ul class="collapse">
  <li><a href="#generic-options" id="toc-generic-options" class="nav-link" data-scroll-target="#generic-options">Generic options:</a></li>
  <li><a href="#output-options" id="toc-output-options" class="nav-link" data-scroll-target="#output-options">Output options:</a></li>
  <li><a href="#bolt-generic-options" id="toc-bolt-generic-options" class="nav-link" data-scroll-target="#bolt-generic-options">BOLT generic options:</a></li>
  <li><a href="#bolt-optimization-options" id="toc-bolt-optimization-options" class="nav-link" data-scroll-target="#bolt-optimization-options">BOLT optimization options:</a></li>
  <li><a href="#bolt-options-in-relocation-mode" id="toc-bolt-options-in-relocation-mode" class="nav-link" data-scroll-target="#bolt-options-in-relocation-mode">BOLT options in relocation mode:</a></li>
  <li><a href="#bolt-instrumentation-options" id="toc-bolt-instrumentation-options" class="nav-link" data-scroll-target="#bolt-instrumentation-options">BOLT instrumentation options:</a></li>
  <li><a href="#bolt-printing-options" id="toc-bolt-printing-options" class="nav-link" data-scroll-target="#bolt-printing-options">BOLT printing options:</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="bolt---a-post-link-optimizer-developed-to-speed-up-large-applications" class="level1">
<h1>BOLT - a post-link optimizer developed to speed up large applications</h1>
<section id="synopsis" class="level2">
<h2 class="anchored" data-anchor-id="synopsis">SYNOPSIS</h2>
<p><code>llvm-bolt &lt;executable&gt; [-o outputfile] &lt;executable&gt;.bolt [-data=perf.fdata] [options]</code></p>
</section>
<section id="options" class="level2">
<h2 class="anchored" data-anchor-id="options">OPTIONS</h2>
<section id="generic-options" class="level3">
<h3 class="anchored" data-anchor-id="generic-options">Generic options:</h3>
<ul>
<li><p><code>-h</code></p>
<p>Alias for –help</p></li>
<li><p><code>--help</code></p>
<p>Display available options (–help-hidden for more)</p></li>
<li><p><code>--help-hidden</code></p>
<p>Display all available options</p></li>
<li><p><code>--help-list</code></p>
<p>Display list of available options (–help-list-hidden for more)</p></li>
<li><p><code>--help-list-hidden</code></p>
<p>Display list of all available options</p></li>
<li><p><code>--version</code></p>
<p>Display the version of this program</p></li>
</ul>
</section>
<section id="output-options" class="level3">
<h3 class="anchored" data-anchor-id="output-options">Output options:</h3>
<ul>
<li><p><code>--bolt-info</code></p>
<p>Write bolt info section in the output binary</p></li>
<li><p><code>-o &lt;string&gt;</code></p>
<p>output file</p></li>
<li><p><code>-w &lt;string&gt;</code></p>
<p>Save recorded profile to a file</p></li>
</ul>
</section>
<section id="bolt-generic-options" class="level3">
<h3 class="anchored" data-anchor-id="bolt-generic-options">BOLT generic options:</h3>
<ul>
<li><p><code>--align-text=&lt;uint&gt;</code></p>
<p>Alignment of .text section</p></li>
<li><p><code>--allow-stripped</code></p>
<p>Allow processing of stripped binaries</p></li>
<li><p><code>--alt-inst-feature-size=&lt;uint&gt;</code></p>
<p>Size of feature field in .altinstructions</p></li>
<li><p><code>--alt-inst-has-padlen</code></p>
<p>Specify that .altinstructions has padlen field</p></li>
<li><p><code>--asm-dump[=&lt;dump folder&gt;]</code></p>
<p>Dump function into assembly</p></li>
<li><p><code>-b</code></p>
<p>Alias for -data</p></li>
<li><p><code>--bolt-id=&lt;string&gt;</code></p>
<p>Add any string to tag this execution in the output binary via bolt info section</p></li>
<li><p><code>--break-funcs=&lt;func1,func2,func3,...&gt;</code></p>
<p>List of functions to core dump on (debugging)</p></li>
<li><p><code>--check-encoding</code></p>
<p>Perform verification of LLVM instruction encoding/decoding. Every instruction in the input is decoded and re-encoded. If the resulting bytes do not match the input, a warning message is printed.</p></li>
<li><p><code>--comp-dir-override=&lt;string&gt;</code></p>
<p>Overrides DW_AT_comp_dir, and provides an alternative base location, which is used with DW_AT_dwo_name to construct a path to *.dwo files.</p></li>
<li><p><code>--create-debug-names-section</code></p>
<p>Creates .debug_names section, if the input binary doesn’t have it already, for DWARF5 CU/TUs.</p></li>
<li><p><code>--cu-processing-batch-size=&lt;uint&gt;</code></p>
<p>Specifies the size of batches for processing CUs. Higher number has better performance, but more memory usage. Default value is 1.</p></li>
<li><p><code>--data=&lt;string&gt;</code></p>
<p>data file</p></li>
<li><p><code>--data2=&lt;string&gt;</code></p>
<p>data file</p></li>
<li><p><code>--debug-skeleton-cu</code></p>
<p>Prints out offsets for abbrev and debug_info of Skeleton CUs that get patched.</p></li>
<li><p><code>--dot-tooltip-code</code></p>
<p>Add basic block instructions as tool tips on nodes</p></li>
<li><p><code>--dump-alt-instructions</code></p>
<p>Dump Linux alternative instructions info</p></li>
<li><p><code>--dump-cg=&lt;string&gt;</code></p>
<p>Dump callgraph to the given file</p></li>
<li><p><code>--dump-data</code></p>
<p>Dump parsed bolt data for debugging</p></li>
<li><p><code>--dump-dot-all</code></p>
<p>Dump function CFGs to graphviz format after each stage;enable ‘-print-loops’ for color-coded blocks</p></li>
<li><p><code>--dump-linux-exceptions</code></p>
<p>Dump Linux kernel exception table</p></li>
<li><p><code>--dump-orc</code></p>
<p>Dump raw ORC unwind information (sorted)</p></li>
<li><p><code>--dump-para-sites</code></p>
<p>Dump Linux kernel paravitual patch sites</p></li>
<li><p><code>--dump-pci-fixups</code></p>
<p>Dump Linux kernel PCI fixup table</p></li>
<li><p><code>--dump-smp-locks</code></p>
<p>Dump Linux kernel SMP locks</p></li>
<li><p><code>--dump-static-calls</code></p>
<p>Dump Linux kernel static calls</p></li>
<li><p><code>--dump-static-keys</code></p>
<p>Dump Linux kernel static keys jump table</p></li>
<li><p><code>--dwarf-output-path=&lt;string&gt;</code></p>
<p>Path to where .dwo files or dwp file will be written out to.</p></li>
<li><p><code>--dwp=&lt;string&gt;</code></p>
<p>Path and name to DWP file.</p></li>
<li><p><code>--dyno-stats</code></p>
<p>Print execution info based on profile</p></li>
<li><p><code>--dyno-stats-all</code></p>
<p>Print dyno stats after each stage</p></li>
<li><p><code>--dyno-stats-scale=&lt;uint&gt;</code></p>
<p>Scale to be applied while reporting dyno stats</p></li>
<li><p><code>--enable-bat</code></p>
<p>Write BOLT Address Translation tables</p></li>
<li><p><code>--force-data-relocations</code></p>
<p>Force relocations to data sections to always be processed</p></li>
<li><p><code>--force-patch</code></p>
<p>Force patching of original entry points</p></li>
<li><p><code>--funcs=&lt;func1,func2,func3,...&gt;</code></p>
<p>Limit optimizations to functions from the list</p></li>
<li><p><code>--funcs-file=&lt;string&gt;</code></p>
<p>File with list of functions to optimize</p></li>
<li><p><code>--funcs-file-no-regex=&lt;string&gt;</code></p>
<p>File with list of functions to optimize (non-regex)</p></li>
<li><p><code>--funcs-no-regex=&lt;func1,func2,func3,...&gt;</code></p>
<p>Limit optimizations to functions from the list (non-regex)</p></li>
<li><p><code>--hot-data</code></p>
<p>Hot data symbols support (relocation mode)</p></li>
<li><p><code>--hot-functions-at-end</code></p>
<p>If reorder-functions is used, order functions putting hottest last</p></li>
<li><p><code>--hot-text</code></p>
<p>Generate hot text symbols. Apply this option to a precompiled binary that manually calls into hugify, such that at runtime hugify call will put hot code into 2M pages. This requires relocation.</p></li>
<li><p><code>--hot-text-move-sections=&lt;sec1,sec2,sec3,...&gt;</code></p>
<p>List of sections containing functions used for hugifying hot text. BOLT makes sure these functions are not placed on the same page as the hot text. (default=‘.stub,.mover’).</p></li>
<li><p><code>--insert-retpolines</code></p>
<p>Run retpoline insertion pass</p></li>
<li><p><code>--keep-aranges</code></p>
<p>Keep or generate .debug_aranges section if .gdb_index is written</p></li>
<li><p><code>--keep-tmp</code></p>
<p>Preserve intermediate .o file</p></li>
<li><p><code>--lite</code></p>
<p>Skip processing of cold functions</p></li>
<li><p><code>--log-file=&lt;string&gt;</code></p>
<p>Redirect journaling to a file instead of stdout/stderr</p></li>
<li><p><code>--long-jump-labels</code></p>
<p>Always use long jumps/nops for Linux kernel static keys</p></li>
<li><p><code>--match-profile-with-function-hash</code></p>
<p>Match profile with function hash</p></li>
<li><p><code>--max-data-relocations=&lt;uint&gt;</code></p>
<p>Maximum number of data relocations to process</p></li>
<li><p><code>--max-funcs=&lt;uint&gt;</code></p>
<p>Maximum number of functions to process</p></li>
<li><p><code>--no-huge-pages</code></p>
<p>Use regular size pages for code alignment</p></li>
<li><p><code>--no-threads</code></p>
<p>Disable multithreading</p></li>
<li><p><code>--pad-funcs=&lt;func1:pad1,func2:pad2,func3:pad3,...&gt;</code></p>
<p>List of functions to pad with amount of bytes</p></li>
<li><p><code>--print-mappings</code></p>
<p>Print mappings in the legend, between characters/blocks and text sections (default false).</p></li>
<li><p><code>--profile-format=&lt;value&gt;</code></p>
<p>Format to dump profile output in aggregation mode, default is fdata</p>
<ul>
<li><code>fdata</code>: offset-based plaintext format</li>
<li><code>yaml</code>: dense YAML representation</li>
</ul></li>
<li><p><code>--r11-availability=&lt;value&gt;</code></p>
<p>Determine the availability of r11 before indirect branches</p>
<ul>
<li><code>never</code>: r11 not available</li>
<li><code>always</code>: r11 available before calls and jumps</li>
<li><code>abi</code>: r11 available before calls but not before jumps</li>
</ul></li>
<li><p><code>--relocs</code></p>
<p>Use relocations in the binary (default=autodetect)</p></li>
<li><p><code>--remove-symtab</code></p>
<p>Remove .symtab section</p></li>
<li><p><code>--reorder-skip-symbols=&lt;symbol1,symbol2,symbol3,...&gt;</code></p>
<p>List of symbol names that cannot be reordered</p></li>
<li><p><code>--reorder-symbols=&lt;symbol1,symbol2,symbol3,...&gt;</code></p>
<p>List of symbol names that can be reordered</p></li>
<li><p><code>--retpoline-lfence</code></p>
<p>Determine if lfence instruction should exist in the retpoline</p></li>
<li><p><code>--skip-funcs=&lt;func1,func2,func3,...&gt;</code></p>
<p>List of functions to skip</p></li>
<li><p><code>--skip-funcs-file=&lt;string&gt;</code></p>
<p>File with list of functions to skip</p></li>
<li><p><code>--strict</code></p>
<p>Trust the input to be from a well-formed source</p></li>
<li><p><code>--tasks-per-thread=&lt;uint&gt;</code></p>
<p>Number of tasks to be created per thread</p></li>
<li><p><code>--terminal-trap</code></p>
<p>Assume that execution stops at trap instruction</p></li>
<li><p><code>--thread-count=&lt;uint&gt;</code></p>
<p>Number of threads</p></li>
<li><p><code>--top-called-limit=&lt;uint&gt;</code></p>
<p>Maximum number of functions to print in top called functions section</p></li>
<li><p><code>--trap-avx512</code></p>
<p>In relocation mode trap upon entry to any function that uses AVX-512 instructions</p></li>
<li><p><code>--trap-old-code</code></p>
<p>Insert traps in old function bodies (relocation mode)</p></li>
<li><p><code>--update-debug-sections</code></p>
<p>Update DWARF debug sections of the executable</p></li>
<li><p><code>--use-gnu-stack</code></p>
<p>Use GNU_STACK program header for new segment (workaround for issues with strip/objcopy)</p></li>
<li><p><code>--use-old-text</code></p>
<p>Re-use space in old .text if possible (relocation mode)</p></li>
<li><p><code>-v &lt;uint&gt;</code></p>
<p>Set verbosity level for diagnostic output</p></li>
<li><p><code>--write-dwp</code></p>
<p>Output a single dwarf package file (dwp) instead of multiple non-relocatable dwarf object files (dwo).</p></li>
</ul>
</section>
<section id="bolt-optimization-options" class="level3">
<h3 class="anchored" data-anchor-id="bolt-optimization-options">BOLT optimization options:</h3>
<ul>
<li><p><code>--align-blocks</code></p>
<p>Align basic blocks</p></li>
<li><p><code>--align-blocks-min-size=&lt;uint&gt;</code></p>
<p>Minimal size of the basic block that should be aligned</p></li>
<li><p><code>--align-blocks-threshold=&lt;uint&gt;</code></p>
<p>Align only blocks with frequency larger than containing function execution frequency specified in percent. E.g. 1000 means aligning blocks that are 10 times more frequently executed than the containing function.</p></li>
<li><p><code>--align-functions=&lt;uint&gt;</code></p>
<p>Align functions at a given value (relocation mode)</p></li>
<li><p><code>--align-functions-max-bytes=&lt;uint&gt;</code></p>
<p>Maximum number of bytes to use to align functions</p></li>
<li><p><code>--assume-abi</code></p>
<p>Assume the ABI is never violated</p></li>
<li><p><code>--block-alignment=&lt;uint&gt;</code></p>
<p>Boundary to use for alignment of basic blocks</p></li>
<li><p><code>--bolt-seed=&lt;uint&gt;</code></p>
<p>Seed for randomization</p></li>
<li><p><code>--cg-from-perf-data</code></p>
<p>Use perf data directly when constructing the call graph for stale functions</p></li>
<li><p><code>--cg-ignore-recursive-calls</code></p>
<p>Ignore recursive calls when constructing the call graph</p></li>
<li><p><code>--cg-use-split-hot-size</code></p>
<p>Use hot/cold data on basic blocks to determine hot sizes for call graph functions</p></li>
<li><p><code>--cold-threshold=&lt;uint&gt;</code></p>
<p>Tenths of percents of main entry frequency to use as a threshold when evaluating whether a basic block is cold (0 means it is only considered cold if the block has zero samples). Default: 0</p></li>
<li><p><code>--elim-link-veneers</code></p>
<p>Run veneer elimination pass</p></li>
<li><p><code>--eliminate-unreachable</code></p>
<p>Eliminate unreachable code</p></li>
<li><p><code>--equalize-bb-counts</code></p>
<p>Use same count for BBs that should have equivalent count (used in non-LBR and shrink wrapping)</p></li>
<li><p><code>--execution-count-threshold=&lt;uint&gt;</code></p>
<p>Perform profiling accuracy-sensitive optimizations only if function execution count &gt;= the threshold (default: 0)</p></li>
<li><p><code>--fix-block-counts</code></p>
<p>Adjust block counts based on outgoing branch counts</p></li>
<li><p><code>--fix-func-counts</code></p>
<p>Adjust function counts based on basic blocks execution count</p></li>
<li><p><code>--force-inline=&lt;func1,func2,func3,...&gt;</code></p>
<p>List of functions to always consider for inlining</p></li>
<li><p><code>--frame-opt=&lt;value&gt;</code></p>
<p>Optimize stack frame accesses</p>
<ul>
<li><code>none</code>: do not perform frame optimization</li>
<li><code>hot</code>: perform FOP on hot functions</li>
<li><code>all</code>: perform FOP on all functions</li>
</ul></li>
<li><p><code>--frame-opt-rm-stores</code></p>
<p>Apply additional analysis to remove stores (experimental)</p></li>
<li><p><code>--function-order=&lt;string&gt;</code></p>
<p>File containing an ordered list of functions to use for function reordering</p></li>
<li><p><code>--generate-function-order=&lt;string&gt;</code></p>
<p>File to dump the ordered list of functions to use for function reordering</p></li>
<li><p><code>--generate-link-sections=&lt;string&gt;</code></p>
<p>Generate a list of function sections in a format suitable for inclusion in a linker script</p></li>
<li><p><code>--group-stubs</code></p>
<p>Share stubs across functions</p></li>
<li><p><code>--hugify</code></p>
<p>Automatically put hot code on 2MB page(s) (hugify) at runtime. No manual call to hugify is needed in the binary (which is what –hot-text relies on).</p></li>
<li><p><code>--icf</code></p>
<p>Fold functions with identical code</p></li>
<li><p><code>--icp</code></p>
<p>Alias for –indirect-call-promotion</p></li>
<li><p><code>--icp-calls-remaining-percent-threshold=&lt;uint&gt;</code></p>
<p>The percentage threshold against remaining unpromoted indirect call count for the promotion for calls</p></li>
<li><p><code>--icp-calls-topn</code></p>
<p>Alias for –indirect-call-promotion-calls-topn</p></li>
<li><p><code>--icp-calls-total-percent-threshold=&lt;uint&gt;</code></p>
<p>The percentage threshold against total count for the promotion for calls</p></li>
<li><p><code>--icp-eliminate-loads</code></p>
<p>Enable load elimination using memory profiling data when performing ICP</p></li>
<li><p><code>--icp-funcs=&lt;func1,func2,func3,...&gt;</code></p>
<p>List of functions to enable ICP for</p></li>
<li><p><code>--icp-inline</code></p>
<p>Only promote call targets eligible for inlining</p></li>
<li><p><code>--icp-jt-remaining-percent-threshold=&lt;uint&gt;</code></p>
<p>The percentage threshold against remaining unpromoted indirect call count for the promotion for jump tables</p></li>
<li><p><code>--icp-jt-targets</code></p>
<p>Alias for –icp-jump-tables-targets</p></li>
<li><p><code>--icp-jt-topn</code></p>
<p>Alias for –indirect-call-promotion-jump-tables-topn</p></li>
<li><p><code>--icp-jt-total-percent-threshold=&lt;uint&gt;</code></p>
<p>The percentage threshold against total count for the promotion for jump tables</p></li>
<li><p><code>--icp-jump-tables-targets</code></p>
<p>For jump tables, optimize indirect jmp targets instead of indices</p></li>
<li><p><code>--icp-mp-threshold</code></p>
<p>Alias for –indirect-call-promotion-mispredict-threshold</p></li>
<li><p><code>--icp-old-code-sequence</code></p>
<p>Use old code sequence for promoted calls</p></li>
<li><p><code>--icp-top-callsites=&lt;uint&gt;</code></p>
<p>Optimize hottest calls until at least this percentage of all indirect calls frequency is covered. 0 = all callsites</p></li>
<li><p><code>--icp-topn</code></p>
<p>Alias for –indirect-call-promotion-topn</p></li>
<li><p><code>--icp-use-mp</code></p>
<p>Alias for –indirect-call-promotion-use-mispredicts</p></li>
<li><p><code>--indirect-call-promotion=&lt;value&gt;</code></p>
<p>Indirect call promotion</p>
<ul>
<li><code>none</code>: do not perform indirect call promotion</li>
<li><code>calls</code>: perform ICP on indirect calls</li>
<li><code>jump-tables</code>: perform ICP on jump tables</li>
<li><code>all</code>: perform ICP on calls and jump tables</li>
</ul></li>
<li><p><code>--indirect-call-promotion-calls-topn=&lt;uint&gt;</code></p>
<p>Limit number of targets to consider when doing indirect call promotion on calls. 0 = no limit</p></li>
<li><p><code>--indirect-call-promotion-jump-tables-topn=&lt;uint&gt;</code></p>
<p>Limit number of targets to consider when doing indirect call promotion on jump tables. 0 = no limit</p></li>
<li><p><code>--indirect-call-promotion-topn=&lt;uint&gt;</code></p>
<p>Limit number of targets to consider when doing indirect call promotion. 0 = no limit</p></li>
<li><p><code>--indirect-call-promotion-use-mispredicts</code></p>
<p>Use misprediction frequency for determining whether or not ICP should be applied at a callsite. The -indirect-call-promotion-mispredict-threshold value will be used by this heuristic</p></li>
<li><p><code>--infer-fall-throughs</code></p>
<p>Infer execution count for fall-through blocks</p></li>
<li><p><code>--infer-stale-profile</code></p>
<p>Infer counts from stale profile data.</p></li>
<li><p><code>--inline-all</code></p>
<p>Inline all functions</p></li>
<li><p><code>--inline-ap</code></p>
<p>Adjust function profile after inlining</p></li>
<li><p><code>--inline-limit=&lt;uint&gt;</code></p>
<p>Maximum number of call sites to inline</p></li>
<li><p><code>--inline-max-iters=&lt;uint&gt;</code></p>
<p>Maximum number of inline iterations</p></li>
<li><p><code>--inline-memcpy</code></p>
<p>Inline memcpy using ‘rep movsb’ instruction (X86-only)</p></li>
<li><p><code>--inline-small-functions</code></p>
<p>Inline functions if increase in size is less than defined by -inline-small- functions-bytes</p></li>
<li><p><code>--inline-small-functions-bytes=&lt;uint&gt;</code></p>
<p>Max number of bytes for the function to be considered small for inlining purposes</p></li>
<li><p><code>--instrument</code></p>
<p>Instrument code to generate accurate profile data</p></li>
<li><p><code>--iterative-guess</code></p>
<p>In non-LBR mode, guess edge counts using iterative technique</p></li>
<li><p><code>--jt-footprint-optimize-for-icache</code></p>
<p>With jt-footprint-reduction, only process PIC jumptables and turn off other transformations that increase code size</p></li>
<li><p><code>--jt-footprint-reduction</code></p>
<p>Make jump tables size smaller at the cost of using more instructions at jump sites</p></li>
<li><p><code>--jump-tables=&lt;value&gt;</code></p>
<p>Jump tables support (default=basic)</p>
<ul>
<li><code>none</code>: do not optimize functions with jump tables</li>
<li><code>basic</code>: optimize functions with jump tables</li>
<li><code>move</code>: move jump tables to a separate section</li>
<li><code>split</code>: split jump tables section into hot and cold based on function execution frequency</li>
<li><code>aggressive</code>: aggressively split jump tables section based on usage of the tables</li>
</ul></li>
<li><p><code>--keep-nops</code></p>
<p>Keep no-op instructions. By default they are removed.</p></li>
<li><p><code>--lite-threshold-count=&lt;uint&gt;</code></p>
<p>Similar to ‘-lite-threshold-pct’ but specify threshold using absolute function call count. I.e. limit processing to functions executed at least the specified number of times.</p></li>
<li><p><code>--lite-threshold-pct=&lt;uint&gt;</code></p>
<p>Threshold (in percent) for selecting functions to process in lite mode. Higher threshold means fewer functions to process. E.g threshold of 90 means only top 10 percent of functions with profile will be processed.</p></li>
<li><p><code>--match-with-call-graph</code></p>
<p>Match functions with call graph</p></li>
<li><p><code>--memcpy1-spec=&lt;func1,func2:cs1:cs2,func3:cs1,...&gt;</code></p>
<p>List of functions with call sites for which to specialize memcpy() for size 1</p></li>
<li><p><code>--min-branch-clusters</code></p>
<p>Use a modified clustering algorithm geared towards minimizing branches</p></li>
<li><p><code>--name-similarity-function-matching-threshold=&lt;uint&gt;</code></p>
<p>Match functions using namespace and edit distance.</p></li>
<li><p><code>--no-inline</code></p>
<p>Disable all inlining (overrides other inlining options)</p></li>
<li><p><code>--no-scan</code></p>
<p>Do not scan cold functions for external references (may result in slower binary)</p></li>
<li><p><code>--peepholes=&lt;value&gt;</code></p>
<p>Enable peephole optimizations</p>
<ul>
<li><code>none</code>: disable peepholes</li>
<li><code>double-jumps</code>: remove double jumps when able</li>
<li><code>tailcall-traps</code>: insert tail call traps</li>
<li><code>useless-branches</code>: remove useless conditional branches</li>
<li><code>all</code>: enable all peephole optimizations</li>
</ul></li>
<li><p><code>--plt=&lt;value&gt;</code></p>
<p>Optimize PLT calls (requires linking with -znow)</p>
<ul>
<li><code>none</code>: do not optimize PLT calls</li>
<li><code>hot</code>: optimize executed (hot) PLT calls</li>
<li><code>all</code>: optimize all PLT calls</li>
</ul></li>
<li><p><code>--preserve-blocks-alignment</code></p>
<p>Try to preserve basic block alignment</p></li>
<li><p><code>--profile-ignore-hash</code></p>
<p>Ignore hash while reading function profile</p></li>
<li><p><code>--profile-use-dfs</code></p>
<p>Use DFS order for YAML profile</p></li>
<li><p><code>--reg-reassign</code></p>
<p>Reassign registers so as to avoid using REX prefixes in hot code</p></li>
<li><p><code>--reorder-blocks=&lt;value&gt;</code></p>
<p>Change layout of basic blocks in a function</p>
<ul>
<li><code>none</code>: do not reorder basic blocks</li>
<li><code>reverse</code>: layout blocks in reverse order</li>
<li><code>normal</code>: perform optimal layout based on profile</li>
<li><code>branch-predictor</code>: perform optimal layout prioritizing branch predictions</li>
<li><code>cache</code>: perform optimal layout prioritizing I-cache behavior</li>
<li><code>cache+</code>: perform layout optimizing I-cache behavior</li>
<li><code>ext-tsp</code>: perform layout optimizing I-cache behavior</li>
<li><code>cluster-shuffle</code>: perform random layout of clusters</li>
</ul></li>
<li><p><code>--reorder-data=&lt;section1,section2,section3,...&gt;</code></p>
<p>List of sections to reorder</p></li>
<li><p><code>--reorder-data-algo=&lt;value&gt;</code></p>
<p>Algorithm used to reorder data sections</p>
<ul>
<li><code>count</code>: sort hot data by read counts</li>
<li><code>funcs</code>: sort hot data by hot function usage and count</li>
</ul></li>
<li><p><code>--reorder-data-inplace</code></p>
<p>Reorder data sections in place</p></li>
<li><p><code>--reorder-data-max-bytes=&lt;uint&gt;</code></p>
<p>Maximum number of bytes to reorder</p></li>
<li><p><code>--reorder-data-max-symbols=&lt;uint&gt;</code></p>
<p>Maximum number of symbols to reorder</p></li>
<li><p><code>--reorder-functions=&lt;value&gt;</code></p>
<p>Reorder and cluster functions (works only with relocations)</p>
<ul>
<li><code>none</code>: do not reorder functions</li>
<li><code>exec-count</code>: order by execution count</li>
<li><code>hfsort</code>: use hfsort algorithm</li>
<li><code>hfsort+</code>: use cache-directed sort</li>
<li><code>cdsort</code>: use cache-directed sort</li>
<li><code>pettis-hansen</code>: use Pettis-Hansen algorithm</li>
<li><code>random</code>: reorder functions randomly</li>
<li><code>user</code>: use function order specified by -function-order</li>
</ul></li>
<li><p><code>--reorder-functions-use-hot-size</code></p>
<p>Use a function’s hot size when doing clustering</p></li>
<li><p><code>--report-bad-layout=&lt;uint&gt;</code></p>
<p>Print top <uint> functions with suboptimal code layout on input</uint></p></li>
<li><p><code>--report-stale</code></p>
<p>Print the list of functions with stale profile</p></li>
<li><p><code>--runtime-hugify-lib=&lt;string&gt;</code></p>
<p>Specify file name of the runtime hugify library</p></li>
<li><p><code>--runtime-instrumentation-lib=&lt;string&gt;</code></p>
<p>Specify file name of the runtime instrumentation library</p></li>
<li><p><code>--sctc-mode=&lt;value&gt;</code></p>
<p>Mode for simplify conditional tail calls</p>
<ul>
<li><code>always</code>: always perform sctc</li>
<li><code>preserve</code>: only perform sctc when branch direction is preserved</li>
<li><code>heuristic</code>: use branch prediction data to control sctc</li>
</ul></li>
<li><p><code>--sequential-disassembly</code></p>
<p>Performs disassembly sequentially</p></li>
<li><p><code>--shrink-wrapping-threshold=&lt;uint&gt;</code></p>
<p>Percentage of prologue execution count to use as threshold when evaluating whether a block is cold enough to be profitable to move eligible spills there</p></li>
<li><p><code>--simplify-conditional-tail-calls</code></p>
<p>Simplify conditional tail calls by removing unnecessary jumps</p></li>
<li><p><code>--simplify-rodata-loads</code></p>
<p>Simplify loads from read-only sections by replacing the memory operand with the constant found in the corresponding section</p></li>
<li><p><code>--split-align-threshold=&lt;uint&gt;</code></p>
<p>When deciding to split a function, apply this alignment while doing the size comparison (see -split-threshold). Default value: 2.</p></li>
<li><p><code>--split-all-cold</code></p>
<p>Outline as many cold basic blocks as possible</p></li>
<li><p><code>--split-eh</code></p>
<p>Split C++ exception handling code</p></li>
<li><p><code>--split-functions</code></p>
<p>Split functions into fragments</p></li>
<li><p><code>--split-strategy=&lt;value&gt;</code></p>
<p>Strategy used to partition blocks into fragments</p>
<ul>
<li><code>profile2</code>: split each function into a hot and cold fragment using profiling information</li>
<li><code>cdsplit</code>: split each function into a hot, warm, and cold fragment using profiling information</li>
<li><code>random2</code>: split each function into a hot and cold fragment at a randomly chosen split point (ignoring any available profiling information)</li>
<li><code>randomN</code>: split each function into N fragments at a randomly chosen split points (ignoring any available profiling information)</li>
<li><code>all</code>: split all basic blocks of each function into fragments such that each fragment contains exactly a single basic block</li>
</ul></li>
<li><p><code>--split-threshold=&lt;uint&gt;</code></p>
<p>Split function only if its main size is reduced by more than given amount of bytes. Default value: 0, i.e.&nbsp;split iff the size is reduced. Note that on some architectures the size can increase after splitting.</p></li>
<li><p><code>--stale-matching-max-func-size=&lt;uint&gt;</code></p>
<p>The maximum size of a function to consider for inference.</p></li>
<li><p><code>--stale-matching-min-matched-block=&lt;uint&gt;</code></p>
<p>Percentage threshold of matched basic blocks at which stale profile inference is executed.</p></li>
<li><p><code>--stale-threshold=&lt;uint&gt;</code></p>
<p>Maximum percentage of stale functions to tolerate (default: 100)</p></li>
<li><p><code>--stoke</code></p>
<p>Turn on the stoke analysis</p></li>
<li><p><code>--strip-rep-ret</code></p>
<p>Strip ‘repz’ prefix from ‘repz retq’ sequence (on by default)</p></li>
<li><p><code>--tail-duplication=&lt;value&gt;</code></p>
<p>Duplicate unconditional branches that cross a cache line</p>
<ul>
<li><code>none</code>: do not apply</li>
<li><code>aggressive</code>: aggressive strategy</li>
<li><code>moderate</code>: moderate strategy</li>
<li><code>cache</code>: cache-aware duplication strategy</li>
</ul></li>
<li><p><code>--tsp-threshold=&lt;uint&gt;</code></p>
<p>Maximum number of hot basic blocks in a function for which to use a precise TSP solution while re-ordering basic blocks</p></li>
<li><p><code>--use-aggr-reg-reassign</code></p>
<p>Use register liveness analysis to try to find more opportunities for -reg- reassign optimization</p></li>
<li><p><code>--use-compact-aligner</code></p>
<p>Use compact approach for aligning functions</p></li>
<li><p><code>--use-edge-counts</code></p>
<p>Use edge count data when doing clustering</p></li>
<li><p><code>--verify-cfg</code></p>
<p>Verify the CFG after every pass</p></li>
<li><p><code>--x86-align-branch-boundary-hot-only</code></p>
<p>Only apply branch boundary alignment in hot code</p></li>
<li><p><code>--x86-strip-redundant-address-size</code></p>
<p>Remove redundant Address-Size override prefix</p></li>
</ul>
</section>
<section id="bolt-options-in-relocation-mode" class="level3">
<h3 class="anchored" data-anchor-id="bolt-options-in-relocation-mode">BOLT options in relocation mode:</h3>
<ul>
<li><p><code>--align-macro-fusion=&lt;value&gt;</code></p>
<p>Fix instruction alignment for macro-fusion (x86 relocation mode)</p>
<ul>
<li><code>none</code>: do not insert alignment no-ops for macro-fusion</li>
<li><code>hot</code>: only insert alignment no-ops on hot execution paths (default)</li>
<li><code>all</code>: always align instructions to allow macro-fusion</li>
</ul></li>
</ul>
</section>
<section id="bolt-instrumentation-options" class="level3">
<h3 class="anchored" data-anchor-id="bolt-instrumentation-options">BOLT instrumentation options:</h3>
<p><code>llvm-bolt &lt;executable&gt; -instrument [-o outputfile] &lt;instrumented-executable&gt;</code></p>
<ul>
<li><p><code>--conservative-instrumentation</code></p>
<p>Disable instrumentation optimizations that sacrifice profile accuracy (for debugging, default: false)</p></li>
<li><p><code>--instrument-calls</code></p>
<p>Record profile for inter-function control flow activity (default: true)</p></li>
<li><p><code>--instrument-hot-only</code></p>
<p>Only insert instrumentation on hot functions (needs profile, default: false)</p></li>
<li><p><code>--instrumentation-binpath=&lt;string&gt;</code></p>
<p>Path to instrumented binary in case if /proc/self/map_files is not accessible due to access restriction issues</p></li>
<li><p><code>--instrumentation-file=&lt;string&gt;</code></p>
<p>File name where instrumented profile will be saved (default: /tmp/prof.fdata)</p></li>
<li><p><code>--instrumentation-file-append-pid</code></p>
<p>Append PID to saved profile file name (default: false)</p></li>
<li><p><code>--instrumentation-no-counters-clear</code></p>
<p>Don’t clear counters across dumps (use with instrumentation-sleep-time option)</p></li>
<li><p><code>--instrumentation-sleep-time=&lt;uint&gt;</code></p>
<p>Interval between profile writes (default: 0 = write only at program end). This is useful for service workloads when you want to dump profile every X minutes or if you are killing the program and the profile is not being dumped at the end.</p></li>
<li><p><code>--instrumentation-wait-forks</code></p>
<p>Wait until all forks of instrumented process will finish (use with instrumentation-sleep-time option)</p></li>
</ul>
</section>
<section id="bolt-printing-options" class="level3">
<h3 class="anchored" data-anchor-id="bolt-printing-options">BOLT printing options:</h3>
<ul>
<li><p><code>--print-aliases</code></p>
<p>Print aliases when printing objects</p></li>
<li><p><code>--print-all</code></p>
<p>Print functions after each stage</p></li>
<li><p><code>--print-cfg</code></p>
<p>Print functions after CFG construction</p></li>
<li><p><code>--print-debug-info</code></p>
<p>Print debug info when printing functions</p></li>
<li><p><code>--print-disasm</code></p>
<p>Print function after disassembly</p></li>
<li><p><code>--print-dyno-opcode-stats=&lt;uint&gt;</code></p>
<p>Print per instruction opcode dyno stats and the functionnames:BB offsets of the nth highest execution counts</p></li>
<li><p><code>--print-dyno-stats-only</code></p>
<p>While printing functions output dyno-stats and skip instructions</p></li>
<li><p><code>--print-exceptions</code></p>
<p>Print exception handling data</p></li>
<li><p><code>--print-globals</code></p>
<p>Print global symbols after disassembly</p></li>
<li><p><code>--print-jump-tables</code></p>
<p>Print jump tables</p></li>
<li><p><code>--print-loops</code></p>
<p>Print loop related information</p></li>
<li><p><code>--print-mem-data</code></p>
<p>Print memory data annotations when printing functions</p></li>
<li><p><code>--print-normalized</code></p>
<p>Print functions after CFG is normalized</p></li>
<li><p><code>--print-only=&lt;func1,func2,func3,...&gt;</code></p>
<p>List of functions to print</p></li>
<li><p><code>--print-orc</code></p>
<p>Print ORC unwind information for instructions</p></li>
<li><p><code>--print-profile</code></p>
<p>Print functions after attaching profile</p></li>
<li><p><code>--print-profile-stats</code></p>
<p>Print profile quality/bias analysis</p></li>
<li><p><code>--print-pseudo-probes=&lt;value&gt;</code></p>
<p>Print pseudo probe info</p>
<ul>
<li><code>decode</code>: decode probes section from binary</li>
<li><code>address_conversion</code>: update address2ProbesMap with output block address</li>
<li><code>encoded_probes</code>: display the encoded probes in binary section</li>
<li><code>all</code>: enable all debugging printout</li>
</ul></li>
<li><p><code>--print-relocations</code></p>
<p>Print relocations when printing functions/objects</p></li>
<li><p><code>--print-reordered-data</code></p>
<p>Print section contents after reordering</p></li>
<li><p><code>--print-retpoline-insertion</code></p>
<p>Print functions after retpoline insertion pass</p></li>
<li><p><code>--print-sdt</code></p>
<p>Print all SDT markers</p></li>
<li><p><code>--print-sections</code></p>
<p>Print all registered sections</p></li>
<li><p><code>--print-unknown</code></p>
<p>Print names of functions with unknown control flow</p></li>
<li><p><code>--time-build</code></p>
<p>Print time spent constructing binary functions</p></li>
<li><p><code>--time-rewrite</code></p>
<p>Print time spent in rewriting passes</p></li>
<li><p><code>--print-after-branch-fixup</code></p>
<p>Print function after fixing local branches</p></li>
<li><p><code>--print-after-jt-footprint-reduction</code></p>
<p>Print function after jt-footprint-reduction pass</p></li>
<li><p><code>--print-after-lowering</code></p>
<p>Print function after instruction lowering</p></li>
<li><p><code>--print-cache-metrics</code></p>
<p>Calculate and print various metrics for instruction cache</p></li>
<li><p><code>--print-clusters</code></p>
<p>Print clusters</p></li>
<li><p><code>--print-estimate-edge-counts</code></p>
<p>Print function after edge counts are set for no-LBR profile</p></li>
<li><p><code>--print-finalized</code></p>
<p>Print function after CFG is finalized</p></li>
<li><p><code>--print-fix-relaxations</code></p>
<p>Print functions after fix relaxations pass</p></li>
<li><p><code>--print-fix-riscv-calls</code></p>
<p>Print functions after fix RISCV calls pass</p></li>
<li><p><code>--print-fop</code></p>
<p>Print functions after frame optimizer pass</p></li>
<li><p><code>--print-function-statistics=&lt;uint&gt;</code></p>
<p>Print statistics about basic block ordering</p></li>
<li><p><code>--print-icf</code></p>
<p>Print functions after ICF optimization</p></li>
<li><p><code>--print-icp</code></p>
<p>Print functions after indirect call promotion</p></li>
<li><p><code>--print-inline</code></p>
<p>Print functions after inlining optimization</p></li>
<li><p><code>--print-large-functions</code></p>
<p>Print functions that could not be overwritten due to excessive size</p></li>
<li><p><code>--print-longjmp</code></p>
<p>Print functions after longjmp pass</p></li>
<li><p><code>--print-optimize-bodyless</code></p>
<p>Print functions after bodyless optimization</p></li>
<li><p><code>--print-output-address-range</code></p>
<p>Print output address range for each basic block in the function whenBinaryFunction::print is called</p></li>
<li><p><code>--print-peepholes</code></p>
<p>Print functions after peephole optimization</p></li>
<li><p><code>--print-plt</code></p>
<p>Print functions after PLT optimization</p></li>
<li><p><code>--print-regreassign</code></p>
<p>Print functions after regreassign pass</p></li>
<li><p><code>--print-reordered</code></p>
<p>Print functions after layout optimization</p></li>
<li><p><code>--print-reordered-functions</code></p>
<p>Print functions after clustering</p></li>
<li><p><code>--print-sctc</code></p>
<p>Print functions after conditional tail call simplification</p></li>
<li><p><code>--print-simplify-rodata-loads</code></p>
<p>Print functions after simplification of RO data loads</p></li>
<li><p><code>--print-sorted-by=&lt;value&gt;</code></p>
<p>Print functions sorted by order of dyno stats</p>
<ul>
<li><code>executed-forward-branches</code>: executed forward branches</li>
<li><code>taken-forward-branches</code>: taken forward branches</li>
<li><code>executed-backward-branches</code>: executed backward branches</li>
<li><code>taken-backward-branches</code>: taken backward branches</li>
<li><code>executed-unconditional-branches</code>: executed unconditional branches</li>
<li><code>all-function-calls</code>: all function calls</li>
<li><code>indirect-calls</code>: indirect calls</li>
<li><code>PLT-calls</code>: PLT calls</li>
<li><code>executed-instructions</code>: executed instructions</li>
<li><code>executed-load-instructions</code>: executed load instructions</li>
<li><code>executed-store-instructions</code>: executed store instructions</li>
<li><code>taken-jump-table-branches</code>: taken jump table branches</li>
<li><code>taken-unknown-indirect-branches</code>: taken unknown indirect branches</li>
<li><code>total-branches</code>: total branches</li>
<li><code>taken-branches</code>: taken branches</li>
<li><code>non-taken-conditional-branches</code>: non-taken conditional branches</li>
<li><code>taken-conditional-branches</code>: taken conditional branches</li>
<li><code>all-conditional-branches</code>: all conditional branches</li>
<li><code>linker-inserted-veneer-calls</code>: linker-inserted veneer calls</li>
<li><code>all</code>: sorted by all names</li>
</ul></li>
<li><p><code>--print-sorted-by-order=&lt;value&gt;</code></p>
<p>Use ascending or descending order when printing functions ordered by dyno stats</p></li>
<li><p><code>--print-split</code></p>
<p>Print functions after code splitting</p></li>
<li><p><code>--print-stoke</code></p>
<p>Print functions after stoke analysis</p></li>
<li><p><code>--print-uce</code></p>
<p>Print functions after unreachable code elimination</p></li>
<li><p><code>--print-veneer-elimination</code></p>
<p>Print functions after veneer elimination pass</p></li>
<li><p><code>--time-opts</code></p>
<p>Print time spent in each optimization</p></li>
<li><p><code>--print-all-options</code></p>
<p>Print all option values after command line parsing</p></li>
<li><p><code>--print-options</code></p>
<p>Print non-default options after command line parsing</p></li>
</ul>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>© 2024, Nam Vien</p>
</div>
  </div>
</footer>




</body></html>